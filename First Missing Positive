Given an unsorted integer array, find the first missing positive integer.

For example,
Given [1,2,0] return 3,
and [3,4,-1,1] return 2.

Your algorithm should run in O(n) time and uses constant space
//我之前想的是使用set容器,这是可以的，代码如下（记得关联容器不能使用resize（）函数）。
class Solution {
public:
    int firstMissingPositive(int A[], int n) {
    set<int> b; //创建一个容器
    for(int i=0; i!=n;i++)
    {
        if(A[i] > 0)  // 将正数放在容器中
        {
            b.insert(A[i]);
        }
    }
    int i = 1; //检查容易中的正数，这里从1开始检查
    for(; i != b.size()+1; i++)  //注意由于检查的都是正数，并且是从1开始检查，所以这里结束的条件为长度加1.
    {                   //如果给出的数组是2，则答案为1；如果不是12345这种连续的正数，如12456，则会提前退出循环，检查不到6。
        if(!b.count(i))
        {
            break;
        } 
    }
        return i;    
    }
};

这里由于所给数组的特殊性，最正确的解法是使用桶排序。
桶排序适用于如：统计高考的分数。一年的全国高考考生人数为900万人，分数使用标准分，最低200 ，最高900 ，
没有小数，如果把这900万数字进行排序，用桶排序比快速排序快。

http://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F维基百科
这里参考了http://www.cnblogs.com/kkun/archive/2011/11/23/bucket_sort.html，以下文字转载过来的
桶排序以下列程序进行：

设置一个定量的数组当作空桶子。
寻访序列，并且把项目一个一个放到对应的桶子去。
对每个不是空的桶子进行排序。
从不是空的桶子里把项目再放回原来的序列中。

1,桶排序是稳定的

2,桶排序是常见排序里最快的一种,比快排还要快…大多数情况下

3,桶排序非常快,但是同时也非常耗空间,基本上是最耗空间的一种排序算法

无序数组有个要求,就是成员隶属于固定(有限的)的区间,如范围为[0-9](考试分数为1-100等)

例如待排数字[6 2 4 1 5 9]

准备10个空桶,最大数个空桶

[6 2 4 1 5 9]           待排数组

[0 0 0 0 0 0 0 0 0 0]   空桶

[0 1 2 3 4 5 6 7 8 9]   桶编号(实际不存在)

1,顺序从待排数组中取出数字,首先6被取出,然后把6入6号桶,这个过程类似这样:空桶[ 待排数组[ 0 ] ] = 待排数组[ 0 ]

[6 2 4 1 5 9]           待排数组

[0 0 0 0 0 0 6 0 0 0]   空桶

[0 1 2 3 4 5 6 7 8 9]   桶编号(实际不存在)


2,顺序从待排数组中取出下一个数字,此时2被取出,将其放入2号桶,是几就放几号桶

[6 2 4 1 5 9]           待排数组

[0 0 2 0 0 0 6 0 0 0]   空桶

[0 1 2 3 4 5 6 7 8 9]   桶编号(实际不存在)
 
3,4,5,6省略,过程一样,全部入桶后变成下边这样

[6 2 4 1 5 9]           待排数组

[0 1 2 0 4 5 6 0 0 9]   空桶

[0 1 2 3 4 5 6 7 8 9]   桶编号(实际不存在)

0表示空桶,跳过,顺序取出即可:1 2 4 5 6 9

***如果有0和负数，可以加上一个数字入桶,出桶的时候再减去这个数字；如果有重复数字，可以使用
vector<int>[] a = new vector<int>[MAX]

下面是关于本题的桶排序的代码：
class Solution {
public:
int firstMissingPositive(int A[], int n) {
  bucket_sort(A, n);
for (int i = 0; i < n; ++i)
  if (A[i] != (i + 1))
    return i + 1; //返回未找到的正数，注意不能使用return A[i]+1
return n + 1;   //因为正数都满足，所以返回的为n+1
}
private:
static void bucket_sort(int A[], int n) {
  for (int i = 0; i < n; i++) {
  while (A[i] != i + 1) {  //直到每个数字放到对应的桶内，参考上面
    if (A[i] <= 0 || A[i] > n || A[i] == A[A[i] - 1]) //   A[i] == A[A[i] - 1]这个条件的意思是说明该值放在了对应的位置了
      break;                                               //，此时不需要交换了
    swap(A[i], A[A[i] - 1]);
  }
  }
}
};
